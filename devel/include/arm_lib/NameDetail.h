// Generated by gencpp from file arm_lib/NameDetail.msg
// DO NOT EDIT!


#ifndef ARM_LIB_MESSAGE_NAMEDETAIL_H
#define ARM_LIB_MESSAGE_NAMEDETAIL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace arm_lib
{
template <class ContainerAllocator>
struct NameDetail_
{
  typedef NameDetail_<ContainerAllocator> Type;

  NameDetail_()
    : firstName()
    , lastName()
    , count(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , alpha(0.0)
    , beta(0.0)
    , gamma(0.0)
    , newXX(0.0)
    , newXY(0.0)
    , newXZ(0.0)
    , newYX(0.0)
    , newYY(0.0)
    , newYZ(0.0)
    , newZX(0.0)
    , newZY(0.0)
    , newZZ(0.0)
    , distance(0.0)
    , finalVectorX1(0.0)
    , finalVectorX2(0.0)
    , finalVectorX3(0.0)
    , finalVectorY1(0.0)
    , finalVectorY2(0.0)
    , finalVectorY3(0.0)
    , finalVectorZ1(0.0)
    , finalVectorZ2(0.0)
    , finalVectorZ3(0.0)  {
    }
  NameDetail_(const ContainerAllocator& _alloc)
    : firstName(_alloc)
    , lastName(_alloc)
    , count(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , alpha(0.0)
    , beta(0.0)
    , gamma(0.0)
    , newXX(0.0)
    , newXY(0.0)
    , newXZ(0.0)
    , newYX(0.0)
    , newYY(0.0)
    , newYZ(0.0)
    , newZX(0.0)
    , newZY(0.0)
    , newZZ(0.0)
    , distance(0.0)
    , finalVectorX1(0.0)
    , finalVectorX2(0.0)
    , finalVectorX3(0.0)
    , finalVectorY1(0.0)
    , finalVectorY2(0.0)
    , finalVectorY3(0.0)
    , finalVectorZ1(0.0)
    , finalVectorZ2(0.0)
    , finalVectorZ3(0.0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _firstName_type;
  _firstName_type firstName;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lastName_type;
  _lastName_type lastName;

   typedef uint8_t _count_type;
  _count_type count;

   typedef float _x_type;
  _x_type x;

   typedef float _y_type;
  _y_type y;

   typedef float _z_type;
  _z_type z;

   typedef float _alpha_type;
  _alpha_type alpha;

   typedef float _beta_type;
  _beta_type beta;

   typedef float _gamma_type;
  _gamma_type gamma;

   typedef float _newXX_type;
  _newXX_type newXX;

   typedef float _newXY_type;
  _newXY_type newXY;

   typedef float _newXZ_type;
  _newXZ_type newXZ;

   typedef float _newYX_type;
  _newYX_type newYX;

   typedef float _newYY_type;
  _newYY_type newYY;

   typedef float _newYZ_type;
  _newYZ_type newYZ;

   typedef float _newZX_type;
  _newZX_type newZX;

   typedef float _newZY_type;
  _newZY_type newZY;

   typedef float _newZZ_type;
  _newZZ_type newZZ;

   typedef float _distance_type;
  _distance_type distance;

   typedef float _finalVectorX1_type;
  _finalVectorX1_type finalVectorX1;

   typedef float _finalVectorX2_type;
  _finalVectorX2_type finalVectorX2;

   typedef float _finalVectorX3_type;
  _finalVectorX3_type finalVectorX3;

   typedef float _finalVectorY1_type;
  _finalVectorY1_type finalVectorY1;

   typedef float _finalVectorY2_type;
  _finalVectorY2_type finalVectorY2;

   typedef float _finalVectorY3_type;
  _finalVectorY3_type finalVectorY3;

   typedef float _finalVectorZ1_type;
  _finalVectorZ1_type finalVectorZ1;

   typedef float _finalVectorZ2_type;
  _finalVectorZ2_type finalVectorZ2;

   typedef float _finalVectorZ3_type;
  _finalVectorZ3_type finalVectorZ3;





  typedef boost::shared_ptr< ::arm_lib::NameDetail_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::arm_lib::NameDetail_<ContainerAllocator> const> ConstPtr;

}; // struct NameDetail_

typedef ::arm_lib::NameDetail_<std::allocator<void> > NameDetail;

typedef boost::shared_ptr< ::arm_lib::NameDetail > NameDetailPtr;
typedef boost::shared_ptr< ::arm_lib::NameDetail const> NameDetailConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::arm_lib::NameDetail_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::arm_lib::NameDetail_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::arm_lib::NameDetail_<ContainerAllocator1> & lhs, const ::arm_lib::NameDetail_<ContainerAllocator2> & rhs)
{
  return lhs.firstName == rhs.firstName &&
    lhs.lastName == rhs.lastName &&
    lhs.count == rhs.count &&
    lhs.x == rhs.x &&
    lhs.y == rhs.y &&
    lhs.z == rhs.z &&
    lhs.alpha == rhs.alpha &&
    lhs.beta == rhs.beta &&
    lhs.gamma == rhs.gamma &&
    lhs.newXX == rhs.newXX &&
    lhs.newXY == rhs.newXY &&
    lhs.newXZ == rhs.newXZ &&
    lhs.newYX == rhs.newYX &&
    lhs.newYY == rhs.newYY &&
    lhs.newYZ == rhs.newYZ &&
    lhs.newZX == rhs.newZX &&
    lhs.newZY == rhs.newZY &&
    lhs.newZZ == rhs.newZZ &&
    lhs.distance == rhs.distance &&
    lhs.finalVectorX1 == rhs.finalVectorX1 &&
    lhs.finalVectorX2 == rhs.finalVectorX2 &&
    lhs.finalVectorX3 == rhs.finalVectorX3 &&
    lhs.finalVectorY1 == rhs.finalVectorY1 &&
    lhs.finalVectorY2 == rhs.finalVectorY2 &&
    lhs.finalVectorY3 == rhs.finalVectorY3 &&
    lhs.finalVectorZ1 == rhs.finalVectorZ1 &&
    lhs.finalVectorZ2 == rhs.finalVectorZ2 &&
    lhs.finalVectorZ3 == rhs.finalVectorZ3;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::arm_lib::NameDetail_<ContainerAllocator1> & lhs, const ::arm_lib::NameDetail_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace arm_lib

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::arm_lib::NameDetail_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::arm_lib::NameDetail_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::arm_lib::NameDetail_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::arm_lib::NameDetail_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::arm_lib::NameDetail_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::arm_lib::NameDetail_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::arm_lib::NameDetail_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2d2e9b0661c09cf072222627b7f8a0f2";
  }

  static const char* value(const ::arm_lib::NameDetail_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2d2e9b0661c09cf0ULL;
  static const uint64_t static_value2 = 0x72222627b7f8a0f2ULL;
};

template<class ContainerAllocator>
struct DataType< ::arm_lib::NameDetail_<ContainerAllocator> >
{
  static const char* value()
  {
    return "arm_lib/NameDetail";
  }

  static const char* value(const ::arm_lib::NameDetail_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::arm_lib::NameDetail_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string firstName\n"
"    string lastName\n"
"        uint8 count\n"
"\n"
"            float32 x\n"
"                float32 y\n"
"                    float32 z\n"
"                        float32 alpha\n"
"                            float32 beta\n"
"                                float32 gamma\n"
"                                    float32 newXX\n"
"                                        float32 newXY\n"
"                                            float32 newXZ\n"
"                                                float32 newYX\n"
"                                                    float32 newYY\n"
"                                                        float32 newYZ\n"
"                                                            float32 newZX\n"
"                                                                float32 newZY\n"
"                                                                    float32 newZZ\n"
"                                                                        float32 distance\n"
"                                                                            float32 finalVectorX1\n"
"                                                                                float32 finalVectorX2\n"
"                                                                                    float32 finalVectorX3\n"
"                                                                                        float32 finalVectorY1\n"
"                                                                                            float32 finalVectorY2\n"
"                                                                                                float32 finalVectorY3\n"
"                                                                                                    float32 finalVectorZ1\n"
"                                                                                                        float32 finalVectorZ2\n"
"                                                                                                            float32 finalVectorZ3\n"
;
  }

  static const char* value(const ::arm_lib::NameDetail_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::arm_lib::NameDetail_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.firstName);
      stream.next(m.lastName);
      stream.next(m.count);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.alpha);
      stream.next(m.beta);
      stream.next(m.gamma);
      stream.next(m.newXX);
      stream.next(m.newXY);
      stream.next(m.newXZ);
      stream.next(m.newYX);
      stream.next(m.newYY);
      stream.next(m.newYZ);
      stream.next(m.newZX);
      stream.next(m.newZY);
      stream.next(m.newZZ);
      stream.next(m.distance);
      stream.next(m.finalVectorX1);
      stream.next(m.finalVectorX2);
      stream.next(m.finalVectorX3);
      stream.next(m.finalVectorY1);
      stream.next(m.finalVectorY2);
      stream.next(m.finalVectorY3);
      stream.next(m.finalVectorZ1);
      stream.next(m.finalVectorZ2);
      stream.next(m.finalVectorZ3);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct NameDetail_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::arm_lib::NameDetail_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::arm_lib::NameDetail_<ContainerAllocator>& v)
  {
    s << indent << "firstName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.firstName);
    s << indent << "lastName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lastName);
    s << indent << "count: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.count);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<float>::stream(s, indent + "  ", v.z);
    s << indent << "alpha: ";
    Printer<float>::stream(s, indent + "  ", v.alpha);
    s << indent << "beta: ";
    Printer<float>::stream(s, indent + "  ", v.beta);
    s << indent << "gamma: ";
    Printer<float>::stream(s, indent + "  ", v.gamma);
    s << indent << "newXX: ";
    Printer<float>::stream(s, indent + "  ", v.newXX);
    s << indent << "newXY: ";
    Printer<float>::stream(s, indent + "  ", v.newXY);
    s << indent << "newXZ: ";
    Printer<float>::stream(s, indent + "  ", v.newXZ);
    s << indent << "newYX: ";
    Printer<float>::stream(s, indent + "  ", v.newYX);
    s << indent << "newYY: ";
    Printer<float>::stream(s, indent + "  ", v.newYY);
    s << indent << "newYZ: ";
    Printer<float>::stream(s, indent + "  ", v.newYZ);
    s << indent << "newZX: ";
    Printer<float>::stream(s, indent + "  ", v.newZX);
    s << indent << "newZY: ";
    Printer<float>::stream(s, indent + "  ", v.newZY);
    s << indent << "newZZ: ";
    Printer<float>::stream(s, indent + "  ", v.newZZ);
    s << indent << "distance: ";
    Printer<float>::stream(s, indent + "  ", v.distance);
    s << indent << "finalVectorX1: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorX1);
    s << indent << "finalVectorX2: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorX2);
    s << indent << "finalVectorX3: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorX3);
    s << indent << "finalVectorY1: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorY1);
    s << indent << "finalVectorY2: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorY2);
    s << indent << "finalVectorY3: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorY3);
    s << indent << "finalVectorZ1: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorZ1);
    s << indent << "finalVectorZ2: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorZ2);
    s << indent << "finalVectorZ3: ";
    Printer<float>::stream(s, indent + "  ", v.finalVectorZ3);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ARM_LIB_MESSAGE_NAMEDETAIL_H
